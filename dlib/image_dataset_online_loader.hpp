#ifndef OCV_DLIB_IMAGE_DATASET_ONLINE_LOADER_HPP
#define OCV_DLIB_IMAGE_DATASET_ONLINE_LOADER_HPP

#include <dlib/data_io.h>
#include <dlib/image_processing.h>

#include <deque>
#include <tuple>
#include <vector>

/*!
 *  \addtogroup ocv
 *  @{
 */
namespace ocv{

/*!
 *  \addtogroup odlib
 *  @{
 */
namespace odlib{

/**
 *Read the image_dataset generated by imglab without loading whole
 *image into the buffer.
 *@code
 * ocv::odlib::image_dataset_online_loader<dlib::matrix<dlib::rgb_pixel>> loader;
 * loader.add_image_dataset("ALB/alb_labels.xml");
 * std::time_t seed = 0;
 * auto im_set = loader.load_random_image(seed);
 *@endcode
 */
template<typename img_type>
class image_dataset_online_loader
{
public:
    image_dataset_online_loader()
    {
    }

    void add_image_dataset(const std::string &filename)
    {
        load_image_dataset(dlib::image_dataset_file(filename));
    }

    void clear()
    {
        files.clear();
        min_rects.clear();
        object_locations.clear();
        should_resizes.clear();
        src_vec.clear();
    }

    /**
     * @brief load image randomly, this function is thread safe
     * @return first is the loaded image, second is associate mmod_rect
     */
    auto load_random_image(std::time_t seed) const
    {
        img_type img;
        dlib::rand rnd(std::time(0)+seed);
        int const index = rnd.get_random_32bit_number()%files.size();
        dlib::load_image(img, files[index].full_name());

        if(should_resizes[index]){
            // if shrinking the image would still result in the smallest box being
            // bigger than the box area threshold then shrink the image.
            double min_rect_size = min_rects[index];
            while(min_rect_size/2/2 > src_vec[index].box_area_thresh())
            {
                dlib::pyramid_down<2> pyr;
                pyr(img);
                min_rect_size *= (1.0/2.0)*(1.0/2.0);
            }
            while(min_rect_size*(2.0/3.0)*(2.0/3.0) > src_vec[index].box_area_thresh())
            {
                dlib::pyramid_down<3> pyr;
                pyr(img);
                min_rect_size *= (2.0/3.0)*(2.0/3.0);
            }
        }

        return std::make_tuple(std::move(img), object_locations[index]);
    }

private:   
    bool check_should_resize(const dlib::image_dataset_file& source,
                             std::vector<dlib::mmod_rect> &rects,
                             double min_rect_size) const
    {
        bool should_resize = false;
        if (!rects.empty())
        {
            // if shrinking the image would still result in the smallest box being
            // bigger than the box area threshold then shrink the image.
            if (rects.size() != 0)
            {
                // if shrinking the image would still result in the smallest box being
                // bigger than the box area threshold then shrink the image.
                while(min_rect_size/2/2 > source.box_area_thresh())
                {
                    dlib::pyramid_down<2> pyr;
                    min_rect_size *= (1.0/2.0)*(1.0/2.0);
                    for (auto&& r : rects)
                        r.rect = pyr.rect_down(r.rect);
                }
                while(min_rect_size*(2.0/3.0)*(2.0/3.0) > source.box_area_thresh())
                {
                    dlib::pyramid_down<3> pyr;
                    min_rect_size *= (2.0/3.0)*(2.0/3.0);
                    for (auto&& r : rects)
                        r.rect = pyr.rect_down(r.rect);
                }
            }
        }

        return should_resize;
    }

    void load_image_dataset (
            const dlib::image_dataset_file& source
            )
    {
        using namespace dlib::image_dataset_metadata;
        dataset data;
        load_image_dataset_metadata(data, source.get_filename());

        std::string const parent(dlib::get_parent_directory(dlib::file(source.get_filename())));
        std::vector<dlib::mmod_rect> rects;
        for (unsigned long i = 0; i < data.images.size(); ++i)
        {
            double min_rect_size = std::numeric_limits<double>::infinity();
            rects.clear();
            for (unsigned long j = 0; j < data.images[i].boxes.size(); ++j)
            {
                if (source.should_load_box(data.images[i].boxes[j]))
                {
                    if (data.images[i].boxes[j].ignore)
                    {
                        rects.emplace_back(ignored_mmod_rect(data.images[i].boxes[j].rect));
                    }
                    else
                    {
                        rects.emplace_back(dlib::mmod_rect(data.images[i].boxes[j].rect));
                        min_rect_size = std::min<double>(min_rect_size, rects.back().rect.area());
                    }
                }
            }

            if (!source.should_skip_empty_images() || rects.size() != 0)
            {
                files.emplace_back(parent + "/" + data.images[i].filename);
                min_rects.emplace_back(min_rect_size);
                should_resizes.emplace_back(check_should_resize(source, rects, min_rect_size));
                object_locations.emplace_back(std::move(rects));
                src_vec.emplace_back(source);
            }
        }
    }

    std::vector<dlib::file> files;
    std::vector<double> min_rects;
    std::vector<std::vector<dlib::mmod_rect>> object_locations;
    std::deque<bool> should_resizes;
    std::vector<dlib::image_dataset_file> src_vec;

};


} /*! @} End of Doxygen Groups*/

} /*! @} End of Doxygen Groups*/

#endif // IMAGE_DATASET_ONLINE_LOADER_HPP
